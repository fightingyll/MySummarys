   **什么是多态？**

1.继承体现了多态，JAVA里没有多继承，一个类之能有一个父类。而继承的表现就是多态。一个父类可以有多个子类，而在子类里可以重写父类的方法（例如方法print()），这样每个子类里重写的代码不一样，自然表现形式就不一样。这样用父类的变量去引用不同的子类，在调用这个相同的方法print()的时候得到的结果和表现形式就不一样了，这就是多态，相同的消息（也就是调用相同的方法）会有不同的结果。
例如A类被几个子类继承，子类都重写了A类中的某个方法M，调用(A类型引用对象a).M的时候就会根据创建a的时候使用的是具体哪个子类而调用相应子类中的方法M，这就体现了程序的多态性。
在父类中声明的方法，可以在子类中进行覆盖（声明为finial的除外），这样，父类的引用在引用子类对象的时候可以做出不同的响应。
所以继承中多态表现为：相同的消息被发送到子类或父类对象上，将导致完全不同的行为。多态允许将子类的对象当作父类的对象使用，某父类型的引用指向其子类型的对象,调用的方法是该子类型的方法。这里引用和调用方法的代码编译前就已经决定了,而引用所指向的对象可以在运行期间动态绑定。
2.接口体现了多态，接口一般是功能的封装，正常一个接口可以有多个实现，根据不同的需求来编写实现类，jvm会自动将实现了接口的类和接口绑定起来，虽然接口本身没有实际意义，但是程序只需要调用接口即可调用实现该接口的特定类的方法，一个接口不同的实现类体现了多态。尽管接口的方法没有实际意义，需要具体的类直接实现接口才可使用，需要什么样的直接实现即可，可插拔式，系统自动将接口和实现类绑定。调用的是接口中声明的方法，而具体的功能是看你是用哪个实现来初始化这个对象的。
JAVA没有多继承，而接口实现了多继承！一个类可以同时实现多个接口从而变相实现多继承，例如
public class Son implements Father1,Father2,Father3{   
}
但是其缺点就是如果向一个java接口加入一个新的方法时，所有实现这个接口的类都得编写具体的实现。


生活中的多态：
关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。


多态性的特征：
发送消息给某个对象，让该对象自行决定响应何种行为。 通过将子类对象引用赋值给超类对象引用变量来实现动态方法调用。 
但是多态性未必一定要用接口，只要在继承的基础上存在方法的重写、重载与动态连接即可体现多态性（如存在继承关系的类之间）
java 的这种机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。
如果a是类A的一个引用，那么，a可以指向类A的一个实例,或者说指向类A的一个子类。 
如果a是接口A的一个引用，那么,a必须指向实现了接口A的一个类的实例。但是jvm会自动将接口引用和实现类绑定。


多态存在的三个必要条件
一、要有继承；
二、要有重写；
三、父类引用指向子类对象。



实现多态的技术支持：动态绑定，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法，下面具体介绍。

程序绑定的概念：
绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定（编译是绑定）和后期绑定（运行是绑定）。
也可以理解为该方法和所属于类是否绑定的关系。

静态绑定：
在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。例如：C。
针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定
 
动态绑定：
后期绑定：在运行时根据具体对象的类型进行绑定。
若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。
动态绑定的过程：
虚拟机提取对象的实际类型的方法表；
虚拟机搜索方法签名；
调用方法。
 
关于绑定相关的总结：
在了解了三者的概念之后，很明显我们发现java属于后期绑定。在java中，几乎所有的方法都是后期绑定的，在运行时动态绑定方法属于子类还是基类。但是也有特殊，针对static方法和final方法由于不能被继承，因此在编译时就可以确定他们的值，他们是属于前期绑定的。特别说明的一点是，private声明的方法和成员变量不能被子类继承，也就是该方法只属于本类，所以方法和类绑定了，所有的private方法都被隐式的指定为final的(由此我们也可以知道：将方法声明为final类型的一是为了防止方法被覆盖，二是为了有效的关闭java中的动态绑定)。java中的后期绑定是有JVM来实现的，我们不用去显式的声明它，而C++则不同,必须明确的声明某个方法具备后期绑定。
 
总结：对于java当中的方法而言，除了final，static，private和构造方法是前期绑定外，其他的方法全部为动态绑定。而动态绑定的典型发生在父类和子类的转换声明之下：jvm在编译类时候，发现如果方法是final，static，private修饰或者构造方法，则判断为静态绑定，是属于类的，它们只可以被该类调用，那么此时这些方法的方法本体可以确定。否则为动态绑定，也就是此时无法确定这些方法可以被谁调用，只有在方法被调用的语句出现时候，再去根据对象引用所指实际对象去确定调用特定类的方法。例如若该方法被父类对象调用，同时该方法在子类中被重写，那么最终就会调用子类覆盖的方法体。
JAVA 虚拟机调用一个类方法时（静态方法），它会基于对象引用的类型(通常在编译时可知)来选择所调用的方法。相反，当虚拟机调用一个实例方法时，它会基于对象实际的类型(只能在运行时得知)来选择所调用的方法，这就是动态绑定，是多态的一种。当程序运行并且使用动态绑定调用方法时，虚拟机必须调用同x所指向的对象的实际类型相匹配的方法版本。动态绑定为解决实际的业务问题提供了很大的灵活性，是一种非常优美的机制。

注意：
与方法不同，在处理java类中的成员变量（实例变量和类变量）时，并不是采用运行时绑定，而是一般意义上的静态绑定。所以在向上转型的情况下，对象的方法可以找到子类，而对象的属性（成员变量）还是父类的属性（子类对父类成员变量的隐藏）


理解了“向上转型”和“类型还原”便于理解多态性，此处不再赘述。
本人csdn转载链接：http://blog.csdn.net/yuliangliang092/article/details/51948283

一个经典的多态题目：

class A ...{  
         public String show(D obj)...{  
                return ("A and D");  
         }   
         public String show(A obj)...{  
                return ("A and A");  
         }   
}   
class B extends A...{  
         public String show(B obj)...{  
                return ("B and B");  
         }  
         public String show(A obj)...{  
                return ("B and A");  
         }   
}  
class C extends B...{}   
class D extends B...{}  


问题：以下输出结果是什么？
A a1 = new A();  
        A a2 = new B();  
        B b = new B();  
        C c = new C();   
        D d = new D();   
        System.out.println(a1.show(b));   ①  
        System.out.println(a1.show(c));   ②  
        System.out.println(a1.show(d));   ③  
        System.out.println(a2.show(b));   ④  
        System.out.println(a2.show(c));   ⑤  
        System.out.println(a2.show(d));   ⑥  
        System.out.println(b.show(b));    ⑦  
        System.out.println(b.show(c));    ⑧  
        System.out.println(b.show(d));    ⑨     


 答案


①   A and A
②   A and A
③   A and D
④   B and A
⑤   B and A
⑥   A and D
⑦   B and B
⑧   B and B
⑨   A and D

解析：
1.实例对象为A，参数为对象B，B为A的子类。执行A.class中show(A obj)
2.同上
3.实例对象为A，参数为对象D，执行A.class中show(D obj)
4.实例对象依然为A，参数为B，本应执行A.class中show(A obj)，但是，B.class重写了show(A obj),所以执行B.class show(A obj)
5.同上
6.执行A.class show(D obj) B中并没有重写。
7，8.实例对象为B，参数为B或者B的子类，执行show(B obj)
9.实例对象为B，参数为D，因为B继承自A，也可以执行A中的show(D obj)


